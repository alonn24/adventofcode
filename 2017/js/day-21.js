let input = '../.. => .../#.#/...\n' +
  '#./.. => ..#/..#/#..\n' +
  '##/.. => .../#../..#\n' +
  '.#/#. => #../.../...\n' +
  '##/#. => #.#/.#./#..\n' +
  '##/## => ..#/#.#/..#\n' +
  '.../.../... => .#../#..#/#.../.#..\n' +
  '#../.../... => ..##/..##/.#.#/....\n' +
  '.#./.../... => ..##/..##/.###/##..\n' +
  '##./.../... => ..../.##./#.##/..#.\n' +
  '#.#/.../... => ####/#.##/#.##/#.#.\n' +
  '###/.../... => #..#/..#./..../##.#\n' +
  '.#./#../... => ..#./.#../...#/#.##\n' +
  '##./#../... => ..../#.##/#..#/.#..\n' +
  '..#/#../... => ##.#/####/###./###.\n' +
  '#.#/#../... => ..../#.##/.###/#.#.\n' +
  '.##/#../... => ..#./##.#/####/..##\n' +
  '###/#../... => ..#./.##./...#/..#.\n' +
  '.../.#./... => .###/#.../.#../####\n' +
  '#../.#./... => ###./.#.#/#.##/##.#\n' +
  '.#./.#./... => ..##/..#./###./..#.\n' +
  '##./.#./... => #..#/..#./###./...#\n' +
  '#.#/.#./... => #.../##.#/#.##/#..#\n' +
  '###/.#./... => ...#/#..#/####/##.#\n' +
  '.#./##./... => #.##/#.##/..../#.#.\n' +
  '##./##./... => ..##/###./..#./####\n' +
  '..#/##./... => ..../##../##.#/.##.\n' +
  '#.#/##./... => ##../####/####/.#.#\n' +
  '.##/##./... => ..../##.#/.###/##..\n' +
  '###/##./... => .#../#.#./.#../..##\n' +
  '.../#.#/... => ####/#.#./..##/#..#\n' +
  '#../#.#/... => .#../.#../#..#/....\n' +
  '.#./#.#/... => ..##/.##./####/#.#.\n' +
  '##./#.#/... => ..#./###./.#../....\n' +
  '#.#/#.#/... => ..#./..#./...#/#...\n' +
  '###/#.#/... => ###./.#../##../####\n' +
  '.../###/... => #.##/####/####/..##\n' +
  '#../###/... => .#.#/...#/###./...#\n' +
  '.#./###/... => ..../.#.#/.#../....\n' +
  '##./###/... => ...#/.###/..../.##.\n' +
  '#.#/###/... => ..##/###./.#../#..#\n' +
  '###/###/... => .###/..#./..#./.###\n' +
  '..#/.../#.. => .##./###./####/#.#.\n' +
  '#.#/.../#.. => ####/#.../#.../..##\n' +
  '.##/.../#.. => ###./#..#/..#./.#..\n' +
  '###/.../#.. => .###/.##./#.#./.###\n' +
  '.##/#../#.. => ##.#/...#/.#.#/...#\n' +
  '###/#../#.. => #.##/..#./..../#..#\n' +
  '..#/.#./#.. => #..#/##.#/.##./####\n' +
  '#.#/.#./#.. => ###./..##/#..#/#..#\n' +
  '.##/.#./#.. => .#../..../...#/...#\n' +
  '###/.#./#.. => .#../##../.###/..#.\n' +
  '.##/##./#.. => ##../..##/##../##.#\n' +
  '###/##./#.. => #.##/#..#/.###/####\n' +
  '#../..#/#.. => ##.#/####/#.../..##\n' +
  '.#./..#/#.. => #..#/..../..../###.\n' +
  '##./..#/#.. => #..#/##.#/##.#/#.#.\n' +
  '#.#/..#/#.. => .###/##.#/####/#...\n' +
  '.##/..#/#.. => ####/.##./...#/#..#\n' +
  '###/..#/#.. => .#.#/####/##.#/...#\n' +
  '#../#.#/#.. => ..##/.##./..##/##..\n' +
  '.#./#.#/#.. => #.../##../..##/..#.\n' +
  '##./#.#/#.. => ...#/##.#/#..#/.#..\n' +
  '..#/#.#/#.. => #.#./##../#.##/###.\n' +
  '#.#/#.#/#.. => ##../##.#/#.#./....\n' +
  '.##/#.#/#.. => ####/...#/####/.#..\n' +
  '###/#.#/#.. => ..../.#../.#../....\n' +
  '#../.##/#.. => .#.#/..#./#..#/.###\n' +
  '.#./.##/#.. => #.../.#.#/.###/.##.\n' +
  '##./.##/#.. => #.#./#.#./.#../###.\n' +
  '#.#/.##/#.. => ####/##../.##./####\n' +
  '.##/.##/#.. => #.../#.#./#.##/###.\n' +
  '###/.##/#.. => ####/####/..../####\n' +
  '#../###/#.. => ####/.##./...#/##.#\n' +
  '.#./###/#.. => .#../#.##/#..#/..##\n' +
  '##./###/#.. => #.#./..##/#.../..##\n' +
  '..#/###/#.. => #.##/.###/#.#./###.\n' +
  '#.#/###/#.. => #.##/#.##/..../#..#\n' +
  '.##/###/#.. => .##./#.#./..##/####\n' +
  '###/###/#.. => .##./#..#/#.../###.\n' +
  '.#./#.#/.#. => #.#./#..#/#..#/##.#\n' +
  '##./#.#/.#. => ...#/#.#./##.#/###.\n' +
  '#.#/#.#/.#. => ##.#/..##/##.#/#.##\n' +
  '###/#.#/.#. => .#.#/..#./##../.##.\n' +
  '.#./###/.#. => #..#/..#./..##/#...\n' +
  '##./###/.#. => ####/.#.#/####/..#.\n' +
  '#.#/###/.#. => #.#./..##/##../#..#\n' +
  '###/###/.#. => ...#/..../..../#.#.\n' +
  '#.#/..#/##. => ..#./.##./###./.#.#\n' +
  '###/..#/##. => #.../###./...#/####\n' +
  '.##/#.#/##. => ..../..../.###/##..\n' +
  '###/#.#/##. => ##../..../#.#./.##.\n' +
  '#.#/.##/##. => .#.#/##../..##/#.#.\n' +
  '###/.##/##. => ###./####/...#/.#..\n' +
  '.##/###/##. => ..##/#.../..##/.#.#\n' +
  '###/###/##. => ..##/...#/.###/.#..\n' +
  '#.#/.../#.# => ..##/#.../##.#/....\n' +
  '###/.../#.# => #.##/#..#/..../##..\n' +
  '###/#../#.# => #.../..../##.#/..#.\n' +
  '#.#/.#./#.# => ###./..##/.#../.##.\n' +
  '###/.#./#.# => ..../#..#/.###/#..#\n' +
  '###/##./#.# => .#.#/###./##.#/.###\n' +
  '#.#/#.#/#.# => ..../..../.##./#..#\n' +
  '###/#.#/#.# => .###/.#.#/...#/.###\n' +
  '#.#/###/#.# => .#.#/##../.#../.#..\n' +
  '###/###/#.# => .#.#/.##./#.##/....\n' +
  '###/#.#/### => ..#./..#./..#./..##\n' +
  '###/###/### => ##.#/..##/.#.#/....'
// input = '../.# => ##./#../...\n' +
//   '.#./..#/### => #..#/..../..../#..#'
const start = '.#.\n' +
  '..#\n' +
  '###'
const rules = input.replace(/#/gi, '1').replace(/\./gi, '0')
  .split('\n').map(entry => {
    const parts = entry.split(' => ')
    return {
      input: parts[0].split('/').map(x => x.split('').map(x => +x)),
      output: parts[1].split('/').map(x => x.split('').map(x => +x)),
    }
  })

let grid = start.replace(/#/gi, '1').replace(/\./gi, '0')
  .split('\n').map(x => x.split('').map(x => +x))

function flip(grid) {
  const matrix = grid.map(x => [...x])
  var j, k, result, row, value, _i, _j, _len, _len1
  result = []
  for (j = _i = 0, _len = matrix.length; _i < _len; j = ++_i) {
    row = matrix[j]
    for (k = _j = 0, _len1 = row.length; _j < _len1; k = ++_j) {
      value = row[k];
      (result[k] || (result[k] = []))[j] = value
    }
  }
  return result
}

function rotate(grid) {
  const matrix = grid.map(x => [...x])
  var n = matrix[0].length
  var temp

  // Walk through columns
  for (var i = 0, j = 0; i < n; i++) {
    j = i
    // Walk through rows
    while (j < n) {
      if (i !== j) {
        temp = matrix[i][j]
        matrix[i][j] = matrix[j][i]
        matrix[j][i] = temp
      }
      j++
    }
  }
  for (i in matrix) {
    matrix[i] = matrix[i].reverse()
  }
  return matrix
}

const getGridKey = grid => grid.map(x => x.join(',')).join('/')

let fitCache = {};
function isFit(grid, rule) {
  let gridKey = getGridKey(grid)
  let ruleKey = getGridKey(rule)
  if (fitCache[`${gridKey}~${ruleKey}`] !== void 0) {
    return fitCache[`${gridKey}~${ruleKey}`];
  }

  let temp
  let count = 0
  let valid = gridKey === ruleKey
  while (!valid && count <= 6) {
    count++
    if (count === 3) {
      temp = flip(grid)
      if (getGridKey(temp) === getGridKey) {
        break
      }
      valid = getGridKey(temp) === ruleKey
    } else {
      temp = rotate(temp || grid)
      valid = getGridKey(temp) === ruleKey
    }
  }
  fitCache[`${gridKey}~${ruleKey}`] = valid;
  return valid
}

function transform(grid) {
  for (let i = 0; i < rules.length; i++) {
    const rule = rules[i]
    if (rule.input.length === grid.length && isFit(grid, rule.input)) {
      return rule.output
    }
  }
  throw 'no rule found';
}

function takeSubGrid(grid, i, j, size) {
  return grid.slice(i, i + size).map(x => x.slice(j, j + size))
}

function run(grid, times) {
  let result = grid.map(x => [...x])
  for (let time = 0; time < times; time++) {
    let divBy = result.length % 2 === 0 ? 2 : 3
    let numOfSquers = result.length / divBy
    let subgrids = []
    for (let i = 0; i < numOfSquers; i++) {
      for (let j = 0; j < numOfSquers; j++) {
        const subGrid = takeSubGrid(result, i * divBy, j * divBy, divBy);
        const transformed = transform(subGrid)

        transformed.forEach((row, k) => {
          const writei = i * (divBy + 1)
          subgrids[writei + k] = subgrids[writei + k] || []
          subgrids[writei + k].push(...row)
        })
      }
    }
    result = subgrids
  }
  return result
}

const part1 = run(grid, 5)
console.log(part1.reduce((res, row) => res + row.filter(x => x === 1).length, 0))

const part2 = run(grid, 18)
console.log(part2.reduce((res, row) => res + row.filter(x => x === 1).length, 0))
